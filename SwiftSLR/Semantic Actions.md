# Semantic Actions

Instead of just generating a tree of SLRNode objects (each with a specified type and some number of children), the
user should be able to inject code into each production so that the tree can be transformed into a user-defined type
instead. For instance, the several `Statements -> Statements Statement` productions could use such actions to
automatically flatten the (skewed) tree into `[Statement]`, representing the same thing but being much easier to work
with and reason about.

To allow for such actions, `SLRNode` should be a protocol instead of a class. Each (user-defined) class must conform
to this protocol in order to fit into the stack that holds the shifted terminals and generated non-terminals.

Run-time casting should be used whenever a new node is created using other nodes, since the general `SLRNode` won't fit
into the stricter types required for initializing the left-hand side of a production.

## Example

This will not be generated by SwiftSLR, but rather by the user independently. This is because each class conforming to
SLRNode should be used for further compilation after parsing, so more functionality is probably needed. Therefore, the
user should be free to add whatever methods and fields are needed.

```
class StatementList: SLRNode {
    
    var statements: [Statement]
    
    init(_ statement: Statement) {
        statements = [statement]
    }
    
    init(_ statementList: StatementList, _ statement: Statement) {
        statements = statementList.statements + [statement]
    }
    
}
```

If the user adds the semantic action `{ $0 $1 }` to the production `StatementList -> StatementList Statement`,
the parser will use the second initializer defined in the `StatementList` class. Of course, since SwiftSLR never actually sees
the file containing the class definition, it will just assume it is there (introducing compile-time errors if the user has not
defined the class).

SwiftSLR assumes that the class names are equal to the non-terminals in the production.

If $n refers to a terminal, SwiftSLR will pass the token describing the terminal as its argument to the initializer.
